---
layout: ../../layouts/PostLayout.astro
title: 'Redis Keyspace Notifications üë©üèª‚Äçüíª'
pubDate: 2021/03/02
description: 'O c√≥mo gestionar eventos de expiraci√≥n con Redis'
author: 'Clara Jim√©nez'
image:
    url: '' 
    alt: 'Redis Keyspace Notifications'
tags: ["redis", "microservices", "javascript"]
---
Los sistemas de almacenamiento temporales, como Redis, suelen ser ampliamente utilizados para eliminar parte de carga de las bases de datos, especialmente cuando se trata de consultas pesadas o altamente frecuentes. **Si una consulta se espera que sea realizada con alta frecuencia, podemos hacerla una vez, almacenar la respuesta en una cach√© y las siguientes veces comprobar si el resultado lo tenemos en cach√©** antes de acudir de nuevo a la base de datos. La cach√© ser√° mucho m√°s r√°pida que la base de datos porque almacenar√° los datos en memoria. Tenemos que tener presente, en este caso de soluciones, cada cu√°nto se modifican los datos que estamos consultando en la base de datos. Si esta frecuencia es baja, todo correcto, pero si es m√≠nimamente alta, podemos correr el riesgo de estar recuperando datos de cach√© desactualizados con respecto a los datos persistidos en base de datos. Para evitar problemas como este, tendremos que implementar una pol√≠tica de expiraci√≥n de nuestros datos de cach√©. Cuando los datos expiren, se eliminar√°n de la cach√© autom√°ticamente, evitando as√≠ que los datos de la cach√© queden desactualizados y facilitando su sincronizaci√≥n con la base de datos.

Sin embargo, no es el √∫nico uso que podemos querer dar a un sistema de almacenamiento temporal. Quiz√°s, cuando hay demasiadas peticiones de **escritura con mucha frecuencia en base de datos, preferimos retrasar la persistencia de estos datos y pasar primero por una cach√© que despu√©s volcaremos, con menor frecuencia, a la base de datos**. Aqu√≠ tambi√©n trabajaremos con una pol√≠tica de expiraci√≥n. Cuando los datos expiren, deber√°n persistirse a la base de datos y eliminarse de la cach√©. La diferencia entre este caso de uso y el anterior, es que aqu√≠ necesitamos recuperar los datos que han expirado para procesarlos antes de ser eliminados. Por tanto, no podemos permitir que se eliminen autom√°ticamente tras su expiraci√≥n. Otro caso de uso para el que podemos necesitar recuperar la informaci√≥n que est√° expirando ser√° para cualquier sistema de notificaciones o tareas con fecha de vencimiento programada. Para estos casos de uso, vamos a ver c√≥mo **Redis nos permite gestionar la expiraci√≥n de nuestros datos almacenados en cach√© sin que estos sean eliminados autom√°ticamente gracias a [Redis Keyspace Notifications](https://redis.io/docs/manual/keyspace-notifications/)**.

Gesti√≥n de eventos de expiraci√≥n
---------------------------------

Para gestionar eventos de expiraci√≥n en Redis, la primera idea que debemos tener clara es que, si queremos hacer algo con el objeto almacenado en Redis tras su expiraci√≥n, deberemos manejar dos objetos en Redis asociados de alg√∫n modo a una misma clave. **Un primer objeto almacenar√° la informaci√≥n que queramos recuperar y un segundo objeto no almacenar√° ninguna informaci√≥n relevante pero marcar√° la expiraci√≥n del primer objeto**. Esto debe implementarse as√≠ porque cuando se establece una fecha de expiraci√≥n a un objeto en Redis, este se borra autom√°ticamente y, al suscribirnos a eventos de expiraci√≥n, luego no podremos recuperar la informaci√≥n del objeto que ha expirado porque habr√° sido eliminado autom√°ticamente.

Lo primero que haremos ser√° importar el paquete de [`ioredis`](https://www.npmjs.com/package/ioredis). Inicializamos tambi√©n nuestros clientes de Redis, no olvidando incluir en la configuraci√≥n de uno de ellos `notify-keyspace-events: 'Ex'`, aunque sea program√°ticamente.

```javascript
import Redis from 'ioredis';
const config = { host: '127.0.0.1', port: 6379 };

const redisCache = new Redis(config);
redisCache.on('ready', () => {
  redisCache.config('SET', 'notify-keyspace-events', 'Ex');
});
const expirationSubscriber = new Redis(config);
```

Ahora ya podemos registrar dos objetos asociados a una clave `key`, el que almacena la informaci√≥n y el que gestiona la expiraci√≥n:

```javascript
// Save string in Redis with a particular key
await redisCache.set(key, JSON.stringify(object));

// Generate expiration key in Redis
await redisCache.setex(`reminder:${key}`, TTL, 'expire');
```

Tambi√©n podemos realizar ambas acciones en una misma llamada haciendo uso de `multi()` y `exec()`. Si hubiera alg√∫n error de sintaxis en alguno de los comandos, no se ejecutar√≠a ninguno de ellos.

```javascript
await redisCache.multi().set(key, JSON.stringify(object)).setex(`reminder:${key}`, TTL, 'expire').exec();
```

Ya podemos tambi√©n suscribirnos a eventos de expiraci√≥n en Redis y recoger adecuadamente la informaci√≥n del objeto que est√© expirando:

```javascript
const { db = 0 } = config;
expirationSubscriber.on('ready', () => {
  const expiredSubKey = `__keyevent@${db}__:expired`;
  expirationSubscriber.subscribe(expiredSubKey, () => {
    expirationSubscriber.on('message', async (channel, message) => {
      // Do not execute expirationHandler on every expired event
      if (message.split(':')[0] === 'reminder') {
        await expirationHandler(message);
      }
    });
  });
});

async function expirationHandler(message) {
  message = message.split(':');
  if (message.length >= 2) {
    const key = message[1];
    const object = await redisCache.get(key);
    object = JSON.parse(object);
    // Business logic...
    await redisCache.del(key);
  }
}
```

A su vez, tras recuperar el objeto con clave `key` y tratarlo como sea necesario, debemos borrarlo si as√≠ lo queremos, ya que solo se ha borrado autom√°ticamente el objeto con clave `reminder:[key]`, el cual gestionaba concretamente la expiraci√≥n.

Gesti√≥n de eventos de expiraci√≥n con m√∫ltiples instancias de un mismo microservicio
-----------------------------------------------------------------------------------

El manejo de eventos, ya sea en este caso de expiraci√≥n o debido a cualquier manejo de publicaci√≥n y suscripci√≥n a eventos, puede acabar teniendo varios destinatarios, varios *subscribers*. En el caso de suscripci√≥n a eventos de expiraci√≥n, si son varias instancias las que tenemos del microservicio que se encarga de esto, **todas querr√°n atender a ese evento de expiraci√≥n** y ejecutar√≠an el mismo c√≥digo en paralelo innecesariamente y pudiendo ocasionar errores.

Por esta raz√≥n, queremos **que cuando un objeto expire, sea una sola instancia la que se encargue de manejar su evento de expiraci√≥n**. Esto podremos hacerlo generando el objeto que expira por una instancia y marcando ese objeto para que se sepa qu√© instancia lo registr√≥ y que sea as√≠ esa la √∫nica que ejecute el c√≥digo establecido en su expiraci√≥n. Podemos utilizar la librer√≠a [`anyid`](https://www.npmjs.com/package/anyid) para generar identificadores √∫nicos para cada instancia y marcar los objetos con esos identificadores. Si, cuando un objeto expira, no esta marcado con mi identificador de instancia, es que no soy yo la instancia encargada de gestionar ese objeto.

```javascript
import { anyid } from 'anyid';

const INSTANCEID = generateInstanceId();

function generateInstanceId() {
  return anyid().encode('Aa0').length(8).random().id();
}
```

```javascript
// Save string in Redis with a particular key
await redisCache.set(key, JSON.stringify(object));

// Generate expiration key in Redis (only if it was not generated by another instance before)
redisCache.keys(`reminder:${key}:*`, async (err, keys) => {
  if (!err && keys.length === 0) {
    await redisCache.setex(`reminder:${key}:${INSTANCEID}`, TTL, 'expire');
  }
});
```

```javascript
async function expirationHandler(message) {
  message = message.split(':');
  if (message.length >= 3 && message[2] === INSTANCEID) {
    const key = message[1];
    const object = await redisCache.get(key);
    object = JSON.parse(object);
    // Business logic...
    await redisCache.del(key);
  }
}
```

Pero, un momento, una √∫ltima pregunta: **¬øqu√© pasa si la instancia encargada de atender alguno de los eventos de expiraci√≥n se cae?** Como Redis Pub/Sub tiene un funcionamiento *fire and forget*, perder√≠amos todos los eventos expirados mientras que la instancia haya estado ca√≠da. Si queremos solventar tambi√©n este √∫ltimo punto, **podremos hacer uso de `GETDEL`** y dejar de usar `anyid` para permitir que cualquier instancia atienda a cualquier evento de expiraci√≥n, pero solo una recoger√° el elemento de Redis (la primera que recupere el objeto y lo elimine).

```javascript
async function expirationHandler(message) {
  message = message.split(':');
  if (message.length >= 2) {
    const key = message[1];
    const object = await redisCache.getdel(key);
    if (object) {
      object = JSON.parse(object);
      // Business logic...
    }
  }
}
```

¬øY qu√© pasar√≠a si todas las instancias estuvieran ca√≠das? ü´£ En este caso llegar√≠amos a tener datos *hu√©rfanos*, sin clave de expiraci√≥n asociada, y podr√≠an quedarse en Redis sin llegar a persistirse en base de datos indefinidamente. Para solucionar esto, cada vez que nos llegue informaci√≥n actualizada sobre un objeto que tengamos almacenado en Redis, adem√°s de actualizarla podemos generar su clave de expiraci√≥n si es que esta desapareci√≥:

```javascript
const expirationKey = await redisCache.get(`reminder:${key}`)
if (expirationKey) {
  await redisCache.set(key, JSON.stringify(object));
} else {
  await redisCache.multi().set(key, JSON.stringify(object)).setex(`reminder:${key}`, TTL, 'expire').exec();
}
```

Lo que s√≠ hemos comprobado es que no podr√≠amos recurrir a Redis Keyspace Notifications en caso de necesitar realizar una acci√≥n determinada en el momento justo de recibir un mensaje bajo suscripci√≥n a Redis Pub/Sub. Porque si ese mensaje llega y *no estoy*, lo habr√© perdido para siempre ü•µ.

Ya sab√©is c√≥mo utilizar almacenamiento temporal en cach√©. ¬°Ahora s√≥lo ten√©is que utilizarlo bien!

> ‚ÄúRedis is the most advanced NoSQL database with no single point of failure.‚Äù
>
> ###### Senior IT Architect