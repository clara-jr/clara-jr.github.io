---
layout: ../../layouts/PostLayout.astro
title: 'Callbacks, Promises y Async Await: patrones as√≠ncronos en JavaScript üë©üèª‚Äçüíª'
pubDate: 2020/08/12
description: 'JavaScript no espera a que mi c√≥digo termine para ejecutar lo siguiente, ¬øqu√© puedo hacer?'
author: 'Clara Jim√©nez'
image:
    url: '' 
    alt: 'Async JavaScript'
tags: ["javascript"]
---
El motor de JavaScript es as√≠ncrono y no bloqueante, lo que quiere decir que est√° dise√±ado para no esperar a que un bloque de c√≥digo se ejecute por completo antes de seguir ejecutando las siguientes partes del c√≥digo. En ocasiones es necesario esperar a que una orden se ejecute para ejecutar la funcionalidad siguiente, por ejemplo, si realizamos peticiones a servidores externos, las cuales tardar√°n un tiempo determinado o, incluso, podr√°n resultar en un error que habr√° que tener en cuenta para ejecutar una u otra acci√≥n en nuestro c√≥digo. Debemos esperar hasta conseguir la respuesta de vuelta del servidor para continuar ejecutando cierta parte de nuestro c√≥digo. En este desaf√≠o de programaci√≥n tenemos los callbacks, las promesas y async await.

Utilizamos Callbacks
--------------------

Un callback es una funci√≥n que se pasa a otra funci√≥n como par√°metro, con intenci√≥n de ser invocada seguidamente dentro de la funci√≥n externa para completar alguna acci√≥n. La funci√≥n callback no se ejecuta a menos que sea llamada por la funci√≥n que la contiene: es ‚Äúcalled back‚Äù, de ah√≠ su nombre.

Los callbacks son un concepto b√°sico de la programaci√≥n funcional, en la cual son ampliamente utilizados. Podemos encontrarlas en m√∫ltiples funciones de JavaScript, desde setInterval hasta en peticiones a APIs externas o consultas a bases de datos e incluso en las funciones .map() .reduce() .find() o .filter() propias de la programaci√≥n funcional.

Podemos observar el uso de callbacks en peticiones realizadas a una base de datos, por ejemplo, DynamoDB alojada en AWS. Vemos c√≥mo a nuestra funci√≥n addItem le llega una funci√≥n como par√°metro, es decir, un callback. Adem√°s, este callback tiene dos par√°metros para contemplar posibles errores en su ejecuci√≥n. A su vez, la funci√≥n addItem hace uso del m√©todo PUT del cliente de DynamoDB para AWS en su versi√≥n callback, pas√°ndole de nuevo una funci√≥n como par√°metro, la cual tambi√©n maneja posibles errores en su ejecuci√≥n.

```javascript
// utils.js

const AWS = require('aws-sdk');
const dynamoDb = new AWS.DynamoDB.DocumentClient();
const db = process.env.DB_TABLE;

exports.addItem = (id, name, callback) => {
  const params = {
    TableName: db,
    Item : {
      id,
      name
    }
  };
  dynamoDb.put(params, (error, result) => {
    if (error) callback(error);
    else callback(null, result);
  });
}
```

```javascript
// app.js

const express = require('express');
const app = express();
const bodyParser = require('body-parser');
app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());
const utils = require('utils.js');

app.post('/', (req, res) => {
  const { id, name } = req.body;
  utils.addItem(id, name, (error, result) => {
    if (error) console.log('error: ' + error);
    else console.log('success');
  });
});
```

Bueno, pues en este c√≥digo s√≥lo hemos recurrido a un callback para a√±adir un elemento a una base de datos, pero ¬øy si necesitamos ejecutar varios callbacks anidados? En este momento el c√≥digo se vuelve complicado, tanto su lectura como su mantenimiento a futuro. Y si no lo cre√©is, comprob√©moslo con el siguiente ejemplo.

Imaginemos que, en lugar de hacer una inserci√≥n en la base de datos, hacemos un GET de un elemento en concreto y modificamos uno de sus atributos. Tenemos dos operaciones anidadas y vamos a comprobar el resultado del c√≥digo utilizando callbacks.

```javascript
// utils.js

exports.getItem = (id, callback) => {
  const params = {
    TableName: db,
    Key : {
      id
    }
  };
  return dynamoDb.get(params, (error, result) => {
    if (error) callback(error);
    else callback(null, result);
  });
}

exports.updateItem = (id, name, callback) => {
  const params = {
    TableName: db,
    Key : {
      id
    },
    UpdateExpression: "SET #name=:name",
    ExpressionAttributeNames : {
      "#name": "name"
    },
    ExpressionAttributeValues:{
      ":name": name
    },
    ReturnValues: "ALL_NEW"
  };
  return dynamoDb.update(params), (error, result) => {
    if (error) callback(error);
    else callback(null, result);
  });
}
```

```javascript
// app.js

app.put('/', (req, res) => {
  const { id } = req.body;
  utils.getItem(id, (error, result) => {
    if (error) {
      console.log('error GET: ' + error);
    } else {
      utils.updateItem(id, result.Item.name + '_updated', (error, result) => {
        if (error) console.log('error UPDATE: ' + error);
        else console.log('success');
      });
    }
  });
});
```

Este l√≠o que se forma cuando tenemos varios callbacks anidados es conocido como ‚Äúcallback hell‚Äù. Los callbacks son por tanto √∫tiles para operaciones as√≠ncronas reducidas. Cuando se trabaja con m√∫ltiples operaciones anidadas, no se consideran la mejor pr√°ctica. En este caso, llegan las promesas u objetos Promise, simplificando el mantenimiento de nuestro c√≥digo.

Bueno, mejor utilizamos Promises
--------------------------------

Pues s√≠, justo, las promesas llegan, entre otras cosas, para resolver la infernal anidaci√≥n de callbacks y por tanto, para sustituirlos en ciertas situaciones.

El objeto Promise es usado para computaciones as√≠ncronas. Una promesa representa un valor que puede estar disponible ahora, en el futuro, o nunca. Un objeto Promise se crea de la siguiente manera:

```javascript
new Promise( function(resolve, reject) { ... } );
```

Al crear una promesa, la informaci√≥n que pasamos como par√°metro es adem√°s un callback. Y no s√≥lo eso, si no que esta funci√≥n recibe a su vez como par√°metros dos funciones, o sea ser, dos callbacks: resolve y reject. El callback resolve se ejecutar√° en caso de que todo vaya bien mientras que el callback reject se ejecutar√° en caso de error. Esto desencadenar√° la ejecuci√≥n de una parte del c√≥digo (.then) u otra (.catch) en el lugar en que se llam√≥ a la promesa.

Veamos c√≥mo ser√≠an los dos ejemplos anteriores con el uso de callbacks, en este caso, con el uso de promesas.

```javascript
// utils.js

exports.addItem = (id, name) => {
  const params = {
    TableName: db,
    Item : {
      id,
      name: name
    }
  };
  return dynamoDb.put(params).promise();
}

exports.getItem = (id) => {
  const params = {
    TableName: db,
    Key : {
      id
    }
  };
  return dynamoDb.get(params).promise();
}

exports.updateItem = (id, name) => {
  const params = {
    TableName: db,
    Key : {
      id
    },
    UpdateExpression: "SET #name=:name",
    ExpressionAttributeNames : {
      "#name": "name"
    },
    ExpressionAttributeValues:{
      ":name": name
    },
    ReturnValues: "ALL_NEW"
  };
  return dynamoDb.update(params).promise();
}
```

En el caso del cliente de DynamoDB de AWS, el m√©todo .promise() genera directamente el objeto Promise que devolver√° la ejecuci√≥n del callback resolve o reject seg√∫n el caso, y por tanto, se ejecutar√° una u otra parte de nuestro c√≥digo: .then o .catch respectivamente.

```javascript
// app.js

app.post('/', (req, res) => {
  const { id, name } = req.body;
  utils.addItem(id, name).then(() => {
    console.log('success');
  }).catch(error => {
    console.log('error: ' + error);
  });
};

app.put('/', (req, res) => {
  const { id } = req.body;
  utils.getItem(id).then((result) => {
    return utils.updateItem(result.Item.name + '_updated');
  }).then(() => {
    console.log('success');
  }).catch(error => {
    console.log('error: ' + error);
  });
};
```

Comprobamos c√≥mo, especialmente en el caso de operaciones anidadas, el uso de promesas permite un c√≥digo m√°s limpio y f√°cilmente mantenible. Sin embargo, es cierto que los callbacks permiten un manejo m√°s f√°cil de los errores, identificando r√°pidamente en qu√© callback se produjo el error, mientras que, las promesas recogen todos los errores bajo un solo catch. En este caso, es tarea del desarrollador dise√±ar mensajes de error representativos que faciliten la detecci√≥n del origen del error.

Async Await en ECMAScript 7
---------------------------

Una funci√≥n async tan s√≥lo es una modificaci√≥n de la sintaxis utilizada en la escritura de promesas. Podr√≠amos llamarlo az√∫car sint√°ctico para la implementaci√≥n de promesas, haciendo que escribir promesas sea m√°s f√°cil (s√≠, m√°s todav√≠a). El callback resolve de una promesa se transforma en un mero return y el callback reject pasa a ser un throw.

Async await facilita la comprensi√≥n de nuestro c√≥digo, convirtiendo una funci√≥n cualquiera, en una Promise: async permite devolver una promesa y await indica la llamada a una promesa, un c√≥digo as√≠ncrono al que esperar el t√©rmino de su ejecuci√≥n. Para gestionar el resultado o los errores de este tipo de funciones se puede utilizar try/catch.

```javascript
// app.js

app.post('/', async (req, res) => {
  const { id, name } = req.body;
  try {
    await dynamo.addItem(id, name);
    console.log('success');
  } catch(error) {
    console.log('error: ' + error);
  }
});

app.put('/', async (req, res) => {
  const { id } = req.body;
  try {
    const result = await dynamo.getItem(id);
    await dynamo.updateItem(result.Item.name + '_updated');
    console.log('success');
  } catch(error) {
    console.log('error: ' + error);
  }
});
```

Y recordad: await debe ir siempre dentro de una funci√≥n declarada como as√≠ncrona con async,‚Ä¶ ¬øo no?

Top-Level Await en Node.js v14.8.0
----------------------------------

Top-level await estaba disponible a partir de Node.js v13.3+ haciendo uso del flag --harmony-top-level-await. Esto permit√≠a utilizar await fuera de una funci√≥n declarada con async.

Pero tener que indicar el flag para poder disponer de esta funcionalidad se volv√≠a un poco tedioso y por eso lleg√≥ finalmente la versi√≥n 14 de Node.js en la que ¬°liberaron await de esta flag! Fue concretamente Myles Borins quien liber√≥ ayer a nuestra querida top-level await.

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Happy Top-Level Await Day!!!!! <a href="https://t.co/iI25oDBVZ7">https://t.co/iI25oDBVZ7</a></p>&mdash; sMyle (@MylesBorins) <a href="https://twitter.com/MylesBorins/status/1293230008358625281?ref_src=twsrc%5Etfw">August 11, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

Y con esto y un bizcocho,‚Ä¶ ¬°hasta ECMAScript 8!

> ‚ÄúTop-Level await is the best feature in the JavaScript language in a minute. There are definitely no deep problems with it and no one is worried about deadlock.‚Äù
>
> ###### Myles Borins