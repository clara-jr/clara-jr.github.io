---
layout: ../../layouts/PostLayout.astro
title: 'Motor de b√∫squeda con MongoDB Atlas Search üë©üèª‚Äçüíª'
pubDate: 2023/06/10
description: 'Una soluci√≥n r√°pida y sencilla de b√∫squeda de texto completo'
author: 'Clara Jim√©nez'
image:
    url: '/images/posts/mongo-atlas-search.svg' 
    alt: 'MongoDB Atlas Search'
tags: ["mongodb"]
---
MongoDB Atlas Search permite mantener sincronizada la base de datos con el buscador de texto gracias a tener una funcionalidad de b√∫squeda totalmente integrada con la base de datos en una √∫nica plataforma totalmente administrada. Esto simplifica las consultas de b√∫squeda y reduce el tiempo de desarrollo.

![MongoDB Atlas Search](/images/posts/mongo-atlas-search.svg)

Normalmente, en un buscador los usuarios solemos cometer errores tipogr√°ficos u ortogr√°ficos. A su vez, tambi√©n es probable que incluyamos sin√≥nimos de lo que realmente queremos encontrar. Para estos casos, MongoDB Atlas Search proporciona la posibilidad de realizar b√∫squedas m√°s o menos difusas (*fuzzy searching*) as√≠ como definir t√©rminos de b√∫squeda similares para ayudarnos a encontrar el contenido que buscamos.

## Search indexes

Tenemos que crear un √≠ndice de b√∫squeda (*search index*) para identificar los campos con los que querremos ser capaces de hacer b√∫squedas.

Por ejemplo, con el siguiente √≠ndice estar√≠amos indicando que podremos buscar por todos los atributos de todos los documentos (`"dynamic": true`) de la colecci√≥n, porque estar√≠amos indexando todos los atributos autom√°ticamente:

```json
{
  "mappings": {
    "dynamic": true
  }
}
```

Para reducir el tama√±o de este √≠ndice es preferible especificar los atributos que queramos indexar. Por ejemplo, el √≠ndice para poder buscar elementos de una colecci√≥n a trav√©s de su t√≠tulo o descripci√≥n podr√≠a ser el siguiente:

```json
{
  "mappings": {
    "dynamic": false,
    "fields": {
      "title": {
        "type": "string",
        "analyzer": "lucene.standard"
      },
      "description": {
        "type": "string",
        "analyzer": "lucene.standard"
      }
    }
  }
}
```

Este √≠ndice sirve tanto para el caso de que `translations` sea un objeto con atributos `title` y `description` de tipo string como para el caso de ser ambos arrays de strings.

En caso de que el atributo por el que quisi√©ramos buscar estuviera dentro de un array de objetos, por ejemplo `translations`, con objetos distintos para cada uno de los idiomas soportados, teniendo cada objeto atributos como `lang`, `title` y `description`, el √≠ndice ser√≠a el siguiente:

```json
{
  "mappings": {
    "dynamic": false,
    "fields": {
      "translations": {
        "type": "document",
        "fields": {
          "title": {
            "type": "string",
            "analyzer": "lucene.standard"
          },
          "description":{
            "type": "string",
            "analyzer": "lucene.standard"
          }
        }
      }
    }
  }
}
```

Este √≠ndice sirve tanto para el caso de que `translations` sea un objeto con propiedades `title` y `description` como para el caso mencionado de ser un array de objetos.

En caso de que el atributo por el que quisi√©ramos buscar estuviera embebido en un diccionario, por ejemplo `translations`, con claves para cada uno de los distintos idiomas soportados como `es`, `en`, etc. el √≠ndice ser√≠a el siguiente:

```json
{
  "mappings": {
    "dynamic": false,
    "fields": {
      "translations": {
        "fields": {
          "es": {
            "fields": {
              "title": {
                "type": "string",
                "analyzer": "lucene.standard"
              },
              "description":{
                "type": "string",
                "analyzer": "lucene.standard"
              }
            }
          },
          "en": {
            "fields": {
              "title": {
                "type": "string",
                "analyzer": "lucene.standard"
              },
              "description":{
                "type": "string",
                "analyzer": "lucene.standard"
              }
            }
          }
          ...
        }
      }
    }
  }
}
```

Con `"analyzer": "lucene.standard"` podremos hacer b√∫squedas abarcando cualquier idioma.

## $search aggregation pipeline

La etapa `$search`[\[1\]](https://www.mongodb.com/docs/atlas/atlas-search/query-syntax/#-search), que debe ser siempre la primera del pipeline, permite realizar una b√∫squeda de texto completo en el campo o campos que especifiquemos, teniendo que estar estos campos cubiertos por un √≠ndice de b√∫squeda de Atlas Search. Aqu√≠[\[2\]](https://www.mongodb.com/docs/atlas/atlas-search/operators-and-collectors/#std-label-operators-ref) tenemos una lista de los operadores que podemos usar con `$search`. Vamos a ver algunos de ellos, por ejemplo `text`, `phrase` y `autocomplete`, y los combinaremos a su vez usando `compound`.

### Autocomplete

Este operador permite completar una o varias palabras que le indiquemos como `query` con aquello que sea m√°s probable que se pretenda buscar de entre los valores que se encuentren en los atributos que estemos usando para realizar la b√∫squeda. Antes de usar este operador deberemos indexar los atributos a trav√©s de los que queramos hacer autocompletados con el tipo `autocomplete` en la colecci√≥n que corresponda.

```json
{
  "mappings": {
    "dynamic": false,
    "fields": {
      "title": [
        {
          "type": "autocomplete",
          "analyzer": "lucene.standard",
          "tokenization": "edgeGram",
          "minGrams": 3,
          "maxGrams": 20,
          "foldDiacritics": true
        }
      ],
      "description": [
        {
          "type": "autocomplete",
          "analyzer": "lucene.standard",
          "tokenization": "edgeGram",
          "minGrams": 3,
          "maxGrams": 20,
          "foldDiacritics": true
        }
      ]
    }
  }
}
```

Utilizamos `"tokenization": "edgeGram"` porque es lo que se utiliza para autocompletar con idiomas cuya escritura es de izquierda a derecha. Los par√°metros `minGrams` y `maxGrams` representan el n√∫mero m√≠nimo y m√°ximo de caracteres por secuencia indexada respectivamente; generalmente se empiezan a predecir resultados a partir del tercer caracter introducido en el buscador. Con `foldDiacritics` podemos establecer si somos o no sensitivos frente a tildes diacr√≠ticas. Por ejemplo, con `"foldDiacritics": true` podremos obtener resultados como caf√©, caf√® o cafe indistintamente ante una b√∫squeda con la palabra caf√©.

Ahora ya podemos usar `autocomplete` sobre los atributos indexados:

```json
{
  "$search": {
    "autocomplete": {
      "query": "Pien",
      "path": "title",
      "fuzzy": {
        "maxEdits": 1,
        "prefixLength": 2,
        "maxExpansions": 10
      },
    }
  }
}
```

En el *fuzzy searching* podemos a√±adir tambi√©n el par√°metro `prefixLength` que indicar√° el n√∫mero de caracteres que deben coincidir s√≠ o s√≠ con lo que se vaya a autocompletar (empezando por el primer caracter de la(s) palabra(s) que se indique(n) en la `query`). En el caso del ejemplo, los resultados del autocompletado deber√°n empezar obligatoriamente por *‚ÄúPi‚Äù*. Con `maxEdits` indicamos el n√∫mero de caracteres que permitimos que var√≠en para asumirlos como posibles resultados de la b√∫squeda y con `maxExpansions` indicamos el n√∫mero total de variaciones que aceptamos como v√°lidas dados dichos caracteres variables.

### Text

Con este operador podemos buscar documentos en los que se encuentre(n) la(s) palabra(s) que indiquemos como `query`. Para encontrar palabras parecidas podemos hacer uso del *fuzzy searching* con los par√°metros `maxEdits` y `maxExpansions`. Adem√°s, as√≠ como en el operador `autocomplete` no pod√≠amos indicar m√°s de un atributo de b√∫squeda en el campo `path`, aqu√≠ s√≠ podremos hacerlo.

```json
{
  "$search": {
    "text": {
      "query": "Pienso",
      "path": ["title", "description"],
      "fuzzy": {
        "maxEdits": 1,
        "maxExpansions": 10
      },
    }
  }
}
```

De esta forma, obtendremos todos aquellos documentos que contengan *"Pienso"* en el t√≠tulo o en la descripci√≥n, con las posibles variaciones indicadas en `fuzzy`.

En caso de estar los atributos `title` y `description` dentro de un objeto o array denominado `translations`, por ejemplo, tendr√≠amos `"path": ["translations.title", "translations.description"]`. Para el caso de que `translations` fuera un diccionario con los distintos idiomas disponibles como claves, tendr√≠amos que hacer la b√∫squeda en cuesti√≥n en un idioma en concreto: `"path": ["translations.es.title", "translations.es.description"]`.

### Phrase

Con este operador podemos buscar documentos en los que se encuentren las palabras que indiquemos como `query` en el orden en el que lo escribimos. Es una opci√≥n m√°s acertada que `text` para el caso de estar realizando una b√∫squeda con varias palabras y no solo una. El atributo `slop` permite indicar cu√°ntas palabras permitimos que haya entre las palabras de nuestra `query` como para considerar como v√°lido el resultado de la b√∫squeda.

```json
{
  "$search": {
    "phrase": {
      "query": "Pienso gatos esterilizados",
      "path": ["title", "description"],
      "slop": 2,
    }
  }
}
```

Con esta consulta encontrar√≠amos aquellos documentos que incluyeran en la descripci√≥n la frase ‚ÄúPienso gatos esterilizados‚Äù o cualquier otra variaci√≥n con hasta 2 palabras entre medias.

### Compound

Este operador permite combinar varios operadores en una misma b√∫squeda, por ejemplo `text` y `phrase`. Con este operador podemos usar: `must`,  `should`, `mustNot` y `filter`. Estas condiciones nos permiten indicar qu√© cosas deben o no deben tener obligatoriamente los resultados de la b√∫squeda y qu√© cosas no son obligatorias pero ser√≠an de valor a√±adido, pudiendo aparecer m√°s arriba o m√°s abajo (con mayor o menor `score`) en el orden de los resultados devueltos.

```json
{
  "$search": {
    "compound": {
      "must": [
        {
          "text": {
            "query": "Pienso",
            "path": ["title"],
            "fuzzy": {
              "maxEdits": 1,
              "maxExpansions": 10
            },
          }
        }
      ],
      "should": [
        {
          "phrase": {
            "query": "Pienso gatos esterilizados",
            "path": ["description"],
            "slop": 2,
          }
        }
      ]
    }
  }
}
```

En esta b√∫squeda, por ejemplo, obtendr√≠amos todos los documentos que incluyeran en el t√≠tulo la palabra *"Pienso"* (u otra parecida con un caracter variable hasta 10 posibles variaciones) y, de esos documentos, tendr√≠an mayor `score` aquellos que incluyeran en la descripci√≥n la frase *"Pienso gatos esterilizados"* o cualquier otra variaci√≥n con hasta 2 palabras entre medias, como por ejemplo *"Pienso para gatos esterilizados"*, *"Pienso especial para gatos esterilizados"* o incluso *"Pienso especial para gatos adultos esterilizados"*.

## Un poco m√°s all√°

Una vez visto un poco el funcionamiento de MongoDB Atlas Search y los distintos operadores de la etapa `$search`, vamos a ver tambi√©n alg√∫n que otro impedimento que podr√≠amos encontrar. Por ejemplo, podremos encontrarnos con que el operador `autocomplete` no nos devuelva ning√∫n resultado si lo usamos con cadenas de una √∫nica letra. Para solucionar este comportamiento tendr√≠amos que utilizar analizadores customizados[\[3\]](https://www.mongodb.com/docs/atlas/atlas-search/analyzers/custom/) en lugar de los analizadores que encontramos por defecto en este operador.

Adem√°s, si quisi√©ramos utilizar el operador `autocomplete` en campos que estuviesen dentro de arrays de objetos, como era el caso comentado de un atributo `translations` que conten√≠a un array de objetos con atributos `lang`, `title` y `description`, no podr√≠amos utilizarlo[\[4\]](https://www.mongodb.com/community/forums/t/atlas-search-autocomplete-on-an-array-of-object/13692/9), al menos no directamente.

Tendr√≠amos que redefinir el √≠ndice de b√∫squeda indicando como tipo `embeddedDocuments`[\[5\]](https://www.mongodb.com/docs/atlas/atlas-search/field-types/embedded-documents-type/).

```json
{
  "mappings": {
    "dynamic": false,
    "fields": {
      "translations": {
        "dynamic": false,
        "type": "embeddedDocuments",
        "fields": {
          "title": {
            "type": "autocomplete"
          },
          "description": {
            "type": "autocomplete"
          }
        }
      }
    }
  }
}
```

Y a la hora de usar el operador `autocomplete`, deberemos usarlo tambi√©n de la mano de `embeddedDocument`.

```json
{
  "$search": {
    "embeddedDocument": {
      "path": "translations",
      "operator": {
        "autocomplete": {
          "path": "translations.title",
          "query": "Pien"
        }
      }
    }
  }
}
```

Otra cosa que podemos tener en cuenta sobre la funcionalidad de los operadores de b√∫squeda es que, si introducimos varias palabras en la `query`, Atlas Search buscar√° matches para cada una de las palabras por separado[\[6\]](https://www.mongodb.com/community/forums/t/autocomplete-search-match-multiple-words-in-a-search-term-as-and/16423), no teniendo que contener necesariamente todas las palabras indicadas sino √∫nicamente una de ellas. Es decir, si buscamos *"Pienso gato"*, nos devolver√° resultados que contengan *"Pienso"* o *"gato"*, pudiendo devolvernos *"Pienso para perros"* como resultado. De hecho, resulta antintuitivo porque, funcionando de esta forma, cuantas m√°s palabras escribamos, en lugar de acotarse la b√∫squeda, obtendremos m√°s resultados. Al parecer, por el momento, lo que se sabe de este comportamiento es que *"no es un bug, es una feature"*, as√≠ que ante esta situaci√≥n lo √∫nico que nos queda es echar mano de `compound` y acabar implementando consultas como estas:

```json
{
  "$search": {
    "compound": {
      "must": [
        {
          "autocomplete": {
            "query": "Pienso",
            "path": "title",
            "fuzzy": {
              "maxEdits": 1,
              "maxExpansions": 5,
            },
          },
        },
        {
          "autocomplete": {
            "query": "gato",
            "path": "title",
            "fuzzy": {
              "maxEdits": 1,
              "maxExpansions": 5,
            },
          },
        },
      ]
    },
  },
}
```

Se trata de separar cada palabra y asociarle un operador de autocompletado a cada una, agrup√°ndolas finalmente en un `must`. De esta forma, con esta b√∫squeda obtendremos resultados que contengan tanto *"Pienso"* como *"gato"* en el t√≠tulo del documento. Como estamos separando cada palabra de la b√∫squeda, tendremos que tener en cuenta que, si usamos `autocomplete`, deberemos evitar introducir en la consulta las palabras que tengan una sola letra (a no ser que utilicemos alg√∫n analizador customizado).

```json
{
  "$search": {
    "compound": {
      "must": [
        {
          "compound": {
            "should": [
              {
                "autocomplete": {
                  "query": "Pienso",
                  "path": "title",
                  "fuzzy": {
                    "maxEdits": 1,
                    "maxExpansions": 5,
                  },
                },
              },
              {
                "autocomplete": {
                  "query": "Pienso",
                  "path": "description",
                  "fuzzy": {
                    "maxEdits": 1,
                    "maxExpansions": 5,
                  },
                },
              },
            ],
            "minimumShouldMatch": 1,
          },
        },
        {
          "compound": {
            "should": [
              {
                "autocomplete": {
                  "query": "gato",
                  "path": "title",
                  "fuzzy": {
                    "maxEdits": 1,
                    "maxExpansions": 5,
                  },
                },
              },
              {
                "autocomplete": {
                  "query": "gato",
                  "path": "description",
                  "fuzzy": {
                    "maxEdits": 1,
                    "maxExpansions": 5,
                  },
                },
              },
            ],
            "minimumShouldMatch": 1,
          },
        },
      ]
    },
  },
}
```

Con esta b√∫squeda obtendremos resultados que contengan *"Pienso"* en el t√≠tulo o en la descripci√≥n y que contengan adem√°s *"gato"* en el t√≠tulo o en la descripci√≥n.

> ‚ÄúBecause Atlas Search is embedded right alongside the database, everything is automated for us. Now we‚Äôve got feature releases down to 3 hours, representing a time saving of over 90%‚Äù
>
> ###### Johanes Mangold, Lead Solution Architect, Helvetia